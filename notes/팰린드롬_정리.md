# 팰린드롬(Palindrome) 정리

## 팰린드롬이란?

- **앞뒤가 똑같은 문자열**을 의미합니다
- 숫자나 단어, 문장 등이 앞에서부터 읽어도 뒤에서부터 읽어도 동일한 경우
- 예시: "12321", "level", "racecar", "기러기"

## 기본 판별 방법

### 1. 문자열 뒤집기 비교

```python
def is_palindrome(s):
    return s == s[::-1]

# 예시
print(is_palindrome("12321"))  # True
print(is_palindrome("12345"))  # False
```

### 2. 슬라이싱 `[::-1]` 설명

- `[::-1]`: 전체 문자열을 역순으로 가져옴
- `[시작:끝:간격]`에서 시작과 끝을 생략하고 간격을 -1로 설정
- 예: "hello" → "olleh"

## 백준 1259번 문제 해결

### 문제 요약

- 0이 아닌 숫자가 입력되면 팰린드롬인지 확인
- 팰린드롬이면 "yes", 아니면 "no" 출력
- 0이 입력되면 종료

### 해결 코드

```python
while True:
    N = input()
    if N == "0":
        break
    if N == N[::-1]:
        print("yes")
    else:
        print("no")
```

### 코드 분석

1. `while True`: 무한 루프
2. `N = input()`: 숫자를 문자열로 입력받음
3. `if N == "0": break`: 0이면 종료
4. `if N == N[::-1]:`: 팰린드롬 검사
5. 결과에 따라 "yes" 또는 "no" 출력

## 다른 팰린드롬 판별 방법들

### 1. 투 포인터 방식

```python
def is_palindrome_two_pointer(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

### 2. 재귀 방식

```python
def is_palindrome_recursive(s):
    if len(s) <= 1:
        return True
    if s[0] != s[-1]:
        return False
    return is_palindrome_recursive(s[1:-1])
```

### 3. 리스트 활용

```python
def is_palindrome_list(s):
    return list(s) == list(reversed(s))
```

## 시간복잡도 비교

- **슬라이싱 방식**: O(n) - 가장 간단하고 직관적
- **투 포인터**: O(n) - 메모리 효율적
- **재귀**: O(n) - 스택 오버플로우 위험
- **리스트**: O(n) - 추가 메모리 사용

## 주의사항

1. **문자열로 입력받기**: 숫자를 문자열로 처리해야 함
2. **대소문자 구분**: "Level"과 "level"은 다름
3. **공백 처리**: "race car"와 "racecar"는 다름
4. **특수문자**: 필요에 따라 제거 후 판별

## 관련 문제들

- 백준 1259: 팰린드롬수
- 백준 10988: 팰린드롬인지 확인하기
- 백준 17609: 회문
- 백준 13235: 팰린드롬
