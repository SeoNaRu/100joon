# BOJ 15829: 해시 (문자열 롤링 해시)

- 문제 요지: 문자열 S의 해시값 H를 다음 식으로 계산하고 M(=1234567891)으로 나눈 나머지를 출력
- 식: H = Σ (a_i × r^i) mod M, 보통 r=31, M=1234567891, a_i는 i번째 글자의 값(a=1, b=2, … z=26)

## 핵심 개념

- a_i: i번째 글자의 숫자값 (예: 'a'→1, 'b'→2)
- r^i: 자리 가중치. 10진수에서 일·십·백 자리처럼, r(31)을 반복 곱해 순서를 반영
- mod M: 값이 커지는 것을 방지하면서 결과를 일관되게 유지

## 왜 r=31?

- 작은 소수라 빠르고 분포가 좋음(26보다 큼, 소수)
- 롤링 계산에 유리: power = (power × r) % M로 O(1) 갱신

## 예시 계산

- S = "abcde"

  - 글자값: a=1, b=2, c=3, d=4, e=5
  - r^i: 31^0=1, 31^1=31, 31^2=961, 31^3=29791, 31^4=923521
  - 항들: 1×1 + 2×31 + 3×961 + 4×29791 + 5×923521 = 4,739,715
  - M보다 작으므로 결과는 4,739,715 (mod를 중간중간 적용해도 최종 동일)

- S = "zzz"
  - z=26 → 26×1 + 26×31 + 26×961 = 25,818

## 구현 팁 (파이썬)

```python
M = 1234567891
r = 31

N = int(input())
S = input().strip()

result = 0
power = 1
for i in range(N):
    x = ord(S[i]) - 96  # a=1, b=2, ...
    result = (result + x * power) % M
    power = (power * r) % M

print(result)
```

## 자주 헷갈리는 점

- Σ는 "쭉 더하기" 기호: i를 0부터 l-1까지 바꿔가며 더함
- a_i는 i번째 글자의 값, r^i는 i번째 자리 가중치(31을 i번 곱한 것)
- r^i가 없으면 단순 합이라 순서를 구분 못 하고 충돌↑

## 연결 개념

- 비둘기집 원리: 해시 출력 범위가 유한하므로 충돌 가능성은 원리상 존재
- 암호학적 해시와는 목적이 다름(15829는 보안용 아님, 검색/비교용)
